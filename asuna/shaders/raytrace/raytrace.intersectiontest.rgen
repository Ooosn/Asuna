#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable

#include "../../hostdevice/binding.h"
#include "../../hostdevice/camera.h"
#include "../../hostdevice/pushconstant.h"
#include "common/structs.glsl"
#include "common/math.glsl"

layout(set = 0, binding = eBindingRaytraceTlas, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = eBindingRaytraceImage, set = 0, rgba32f) uniform image2D image;
layout(set = 1, binding = eBindingGraphicCamera) uniform _Camera { Camera cameraInfo; };
layout(location = 0) rayPayloadEXT RayPayload payload;

void main()
{
    mat4 projInv = cameraInfo.projInverse;
    mat4 viewInv = cameraInfo.viewInverse;

    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin     = MINIMUM;
    float tMax     = INFINITY;

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy);
    const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    const vec2 d           = inUV * 2.0 - 1.0;

    const vec4  origin    = cameraInfo.viewInverse * vec4(0.0, 0.0, 0.0, 1.0);
    const vec4  target    = cameraInfo.projInverse * vec4(d.x, d.y, 0.01, 1.0);
    const vec4  direction = cameraInfo.viewInverse * vec4(normalize(target.xyz), 0.0);

    traceRayEXT(
        topLevelAS,             // acceleration structure
        rayFlags,               // rayFlags
        0xFF,                   // cullMask
        0,                      // sbtRecordOffset
        0,                      // sbtRecordStride
        0,                      // missIndex
        origin.xyz,             // ray origin
        tMin,                   // ray min range
        direction.xyz,          // ray direction
        tMax,                   // ray max range
        0                       // payload (location = 0)
    );

    vec3 radiance = payload.radiance;

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(radiance, 1.f));
}