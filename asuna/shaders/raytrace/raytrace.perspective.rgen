#version 460
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable

#include "../../hostdevice/binding.h"
#include "../../hostdevice/camera.h"
#include "../../hostdevice/pushconstant.h"
#include "utils/math.glsl"
#include "utils/structs.glsl"

// clang-format off
layout(push_constant)                                 uniform _RtxState  { GpuPushConstantRaytrace pc; };
layout(set = RtAccel, binding = AccelTlas)            uniform accelerationStructureEXT tlas;
layout(set = RtOut,   binding = OutputStore, rgba32f) uniform image2D   images[NUM_OUTPUT_IMAGES];
layout(set = RtScene, binding = SceneCamera)          uniform _Camera   { GpuCamera cameraInfo; };
// clang-format on

layout(location = 0) rayPayloadEXT RayPayload payload;

void main()
{
  // payload.seed = xxhash32(uvec3(gl_LaunchIDEXT.xy, pc.curFrame));
  initRNG(vec2(gl_LaunchIDEXT.xy), pc.curFrame + 1, payload.seed);

//  debugPrintfEXT("random: %f\n", rand(payload.seed));

  vec4 fxfycxcy = cameraInfo.fxfycxcy;
  vec4 origin   = cameraInfo.viewInverse * vec4(0.0, 0.0, 0.0, 1.0);
  uint rayFlags = gl_RayFlagsCullBackFacingTrianglesEXT;

  vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy);
  if(cameraInfo.type == CameraTypeOpencv)
    pixelCenter.y = gl_LaunchSizeEXT.y - 1 - gl_LaunchIDEXT.y;

  // Initialize the seed for the random number
  vec3 radiance = vec3(0);

  for(uint i = 0; i < pc.spp; ++i)
  {
    vec2 jitter = pc.curFrame == 0 ? vec2(0.5f, 0.5f) : vec2(rand(payload.seed), rand(payload.seed));
    vec2 pixel  = pixelCenter + jitter;

    vec4 target;
    if(cameraInfo.type == CameraTypePerspective)
    {
      vec2 d = pixel / vec2(gl_LaunchSizeEXT.xy) * 2.0 - 1.0;
      target = cameraInfo.projInverse * vec4(d.x, d.y, 1.0, 1.0);
    }
    else if(cameraInfo.type == CameraTypeOpencv)
    {
      vec2 pXy = vec2((pixel.x - fxfycxcy.z) / fxfycxcy.x, (pixel.y - fxfycxcy.w) / fxfycxcy.y);
      target   = -vec4(pXy, 1.0, 1.0);
    }

    vec4 direction = cameraInfo.viewInverse * vec4(normalize(target.xyz), 0.0);

    // Path trace
    payload.ray        = Ray(origin.xyz, direction.xyz);
    payload.bsdf       = BsdfSample(vec3(0.0), 1.0);
    payload.radiance   = vec3(0.0);
    payload.throughput = vec3(1.0);
    payload.absorption = vec3(0.0);
    payload.hitDis     = INFINITY;
    payload.stop       = 0;

    for(payload.depth=0;; ++payload.depth)
    {
      traceRayEXT(tlas,                   // acceleration structure
                  rayFlags,               // rayFlags
                  0xFF,                   // cullMask
                  0,                      // sbtRecordOffset
                  0,                      // sbtRecordStride
                  0,                      // missIndex
                  payload.ray.origin,     // ray origin
                  MINIMUM,                // ray min range
                  payload.ray.direction,  // ray direction
                  INFINITY,               // ray max range
                  0                       // payload (location = 0)
      );

      if(payload.stop > 0)
        break;
    }

    radiance += payload.radiance;
    // debugPrintfEXT("%v3f", payload.radiance);
  }

  radiance /= float(pc.spp);

  // Saving result
  if(pc.curFrame == 0)
  {
    // First frame, replace the value in the buffer
    imageStore(images[0], ivec2(gl_LaunchIDEXT.xy), vec4(radiance, 1.f));
  }
  else
  {
    // Do accumulation over time
    float a         = 1.0f / float(pc.curFrame + 1);
    vec3  old_color = imageLoad(images[0], ivec2(gl_LaunchIDEXT.xy)).xyz;
    imageStore(images[0], ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, radiance, a), 1.f));
  }
}