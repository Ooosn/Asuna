#version 460
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable

#include "../../hostdevice/binding.h"
#include "../../hostdevice/camera.h"
#include "../../hostdevice/pushconstant.h"
#include "common/math.glsl"
#include "common/structs.glsl"

layout(set = 0, binding = eGPUBindingRaytraceTlas,
       set = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = eGPUBindingRaytraceImage, set = 0, rgba32f) uniform image2D image;
layout(set = 1, binding = eGPUBindingGraphicsCamera) uniform _Camera
{
	GPUCamera cameraInfo;
};
layout(location = 0) rayPayloadEXT RayPayload payload;

void main()
{
	mat4 projInv = cameraInfo.projInverse;
	mat4 viewInv = cameraInfo.viewInverse;

	uint  rayFlags = gl_RayFlagsOpaqueEXT;
	float tMin     = MINIMUM;
	float tMax     = INFINITY;

	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy);
	const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	const vec2 d           = inUV * 2.0 - 1.0;

	const vec4 origin    = cameraInfo.viewInverse * vec4(0.0, 0.0, 0.0, 1.0);
	const vec4 target    = cameraInfo.projInverse * vec4(d.x, d.y, 1.0, 1.0);
	const vec4 direction = cameraInfo.viewInverse * vec4(normalize(target.xyz), 0.0);

	//debugPrintfEXT("Target = %v3f", target.xyz);
	debugPrintfEXT("direction = %v3f origin = %v3f", direction.xyz, origin.xyz);

	traceRayEXT(topLevelAS,           // acceleration structure
	            rayFlags,             // rayFlags
	            0xFF,                 // cullMask
	            0,                    // sbtRecordOffset
	            0,                    // sbtRecordStride
	            0,                    // missIndex
	            origin.xyz,           // ray origin
	            tMin,                 // ray min range
	            direction.xyz,        // ray direction
	            tMax,                 // ray max range
	            0                     // payload (location = 0)
	);

	vec3 radiance = payload.radiance;

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(radiance, 1.f));
}