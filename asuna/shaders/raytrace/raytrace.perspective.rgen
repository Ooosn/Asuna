#version 460
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable

#define __raytrace 1

#include "../../hostdevice/binding.h"
#include "../../hostdevice/camera.h"
#include "../../hostdevice/pushconstant.h"
#include "utils/math.glsl"
#include "utils/structs.glsl"

// clang-format off
layout(push_constant)                            uniform RtxState  { GPUPushConstantRaytrace pc; };
layout(set = S_ACCEL, binding = eTlas)           uniform accelerationStructureEXT topLevelAS;
layout(set = S_OUT,   binding = eStore, rgba32f) uniform image2D   images[eNStores];
layout(set = S_SCENE, binding = eCamera)         uniform _Camera   { GPUCamera cameraInfo; };
// clang-format on

layout(location = 0) rayPayloadEXT RayPayload payload;

void main()
{
    // Initialize the seed for the random number
    payload.seed = xxhash32(uvec3(gl_LaunchIDEXT.xy, pc.curFrame));

    vec3       radiance = vec3(0);
    const vec4 origin   = cameraInfo.viewInverse * vec4(0.0, 0.0, 0.0, 1.0);
    uint       rayFlags = gl_RayFlagsCullBackFacingTrianglesEXT;
    float      tMin     = MINIMUM;
    float      tMax     = INFINITY;

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy);
    for (uint i = 0; i < pc.spp; ++i)
    {
        vec2 jitter =
            pc.curFrame == 0 ? vec2(0.5f, 0.5f) : vec2(rand(payload.seed), rand(payload.seed));
        vec2       pixel = pixelCenter + jitter;
        const vec2 inUV  = pixel / vec2(gl_LaunchSizeEXT.xy);
        const vec2 d     = inUV * 2.0 - 1.0;

        const vec4 target    = cameraInfo.projInverse * vec4(d.x, d.y, 1.0, 1.0);
        const vec4 direction = cameraInfo.viewInverse * vec4(normalize(target.xyz), 0.0);

        // Path trace
        payload.ray        = Ray(origin.xyz, direction.xyz);
        payload.bsdf       = BsdfSample(vec3(0.0), 0.0);
        payload.radiance   = vec3(0.0);
        payload.throughput = vec3(1.0);
        payload.absorption = vec3(0.0);
        payload.hitDis     = INFINITY;
        payload.stop       = false;

        for (uint j = 0; j < pc.maxRecursionDepth; ++j)
        {
            payload.depth = j;

            traceRayEXT(topLevelAS,                   // acceleration structure
                        rayFlags,                     // rayFlags
                        0xFF,                         // cullMask
                        0,                            // sbtRecordOffset
                        0,                            // sbtRecordStride
                        0,                            // missIndex
                        payload.ray.origin,           // ray origin
                        tMin,                         // ray min range
                        payload.ray.direction,        // ray direction
                        tMax,                         // ray max range
                        0                             // payload (location = 0)
            );

            if (payload.stop)
                break;
        }

        radiance += payload.radiance;
        // debugPrintfEXT("%v3f", payload.radiance);
    }

    radiance /= float(pc.spp);

    // Saving result
    if (pc.curFrame == 0)
    {
        // First frame, replace the value in the buffer
        imageStore(images[0], ivec2(gl_LaunchIDEXT.xy), vec4(radiance, 1.f));
    }
    else
    {
        // Do accumulation over time
        float a         = 1.0f / float(pc.curFrame + 1);
        vec3  old_color = imageLoad(images[0], ivec2(gl_LaunchIDEXT.xy)).xyz;
        imageStore(images[0], ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, radiance, a), 1.f));
    }
}